using Microsoft.CodeAnalysis;
using System;
using System.Collections.Immutable;

namespace SoftCache.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class SoftCacheGenerator : IIncrementalGenerator
{
    private const string AttributeMetadataName = "SoftCache.Annotations.SoftCacheAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1) Find all types marked with the required attribute
        var optionsProvider =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: AttributeMetadataName,
                    predicate: static (_, _) => true, // Roslyn filters by attribute name itself
                    transform: static (transformContext, cancellationToken) =>
                    {
                        var targetTypeSymbol = (ITypeSymbol)transformContext.TargetSymbol;

                        // Ensure the attribute is exactly our SoftCache.Annotations attribute (and not a namesake)
                        var expectedAttribute =
                            transformContext.SemanticModel.Compilation.GetTypeByMetadataName(AttributeMetadataName);
                        if (expectedAttribute is null)
                        {
                            return (ok: false, options: default(SoftCacheOptions));
                        }

                        var attributeData = transformContext.Attributes
                            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, expectedAttribute));

                        if (attributeData is null)
                        {
                            return (ok: false, options: default(SoftCacheOptions));
                        }

                        var parsedOptions = ParseOptions(attributeData, targetTypeSymbol);
                        return (ok: true, options: parsedOptions);
                    })
                .Where(static tuple => tuple.ok)
                .Select(static (tuple, _) => tuple.options);

        // 2) For now, emit a “debug” file listing parsed options
        context.RegisterSourceOutput(optionsProvider.Collect(), static (productionContext, collectedOptions) =>
        {
            if (collectedOptions.IsDefaultOrEmpty)
            {
                return;
            }

            var sourceText = BuildDebugDump(collectedOptions!);
            productionContext.AddSource("SoftCache.__DebugOptions.g.cs", sourceText);
        });
    }

    private static string BuildDebugDump(ImmutableArray<SoftCacheOptions> options)
    {
        var stringBuilder = new System.Text.StringBuilder();
        stringBuilder.AppendLine("// <auto-generated/>");
        stringBuilder.AppendLine("namespace SoftCache.__Debug;");
        stringBuilder.AppendLine("internal static class ParsedOptionsDump");
        stringBuilder.AppendLine("{");
        stringBuilder.AppendLine("    // This file is for debug only. Remove when real generation is added.");
        stringBuilder.AppendLine("    internal static readonly (string Type, int CacheBits, int Associativity, string HashKind, string Concurrency, bool Seed, bool Metrics, string? Domain)[] Items = new []");
        stringBuilder.AppendLine("    {");
        foreach (var optionsItem in options)
        {
            var typeName = optionsItem.TargetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var hashKind = optionsItem.HashKind.ToString();
            var concurrency = optionsItem.Concurrency.ToString();
            var domainLiteral = optionsItem.Domain is null ? "null" : $"\"{optionsItem.Domain}\"";
            stringBuilder.AppendLine($"        (\"{typeName}\", {optionsItem.CacheBits}, {optionsItem.Associativity}, \"{hashKind}\", \"{concurrency}\", {optionsItem.GenerateGlobalSeed.ToString().ToLowerInvariant()}, {optionsItem.EnableDebugMetrics.ToString().ToLowerInvariant()}, {domainLiteral}),");
        }
        stringBuilder.AppendLine("    };");
        stringBuilder.AppendLine("}");
        return stringBuilder.ToString();
    }

    private static SoftCacheOptions ParseOptions(AttributeData attributeData, ITypeSymbol targetType)
    {
        // Defaults — aligned with your record
        var cacheBits = 16;
        var associativity = 1;
        var hashKind = SoftHashKind.XorFold16;
        var concurrency = SoftCacheConcurrency.None;
        var generateSeed = false;
        var debugMetrics = false;
        string? domain = null;

        foreach (var kv in attributeData.NamedArguments)
        {
            var name = kv.Key;
            var typedConstant = kv.Value;

            switch (name)
            {
                case nameof(SoftCacheOptions.CacheBits):
                    if (typedConstant.Value is int cacheBitsValue)
                    {
                        cacheBits = cacheBitsValue;
                    }
                    break;

                case nameof(SoftCacheOptions.Associativity):
                    if (typedConstant.Value is int associativityValue)
                    {
                        associativity = associativityValue;
                    }
                    break;

                case nameof(SoftCacheOptions.HashKind):
                    if (typedConstant.Value is int hashKindInt)
                    {
                        hashKind = (SoftHashKind)hashKindInt;
                    }
                    else if (typedConstant.Value is { } hashKindObj && hashKindObj is not null &&
                             typedConstant.Type?.TypeKind == TypeKind.Enum)
                    {
                        hashKind = (SoftHashKind)Convert.ToInt32(hashKindObj);
                    }
                    break;

                case nameof(SoftCacheOptions.Concurrency):
                    if (typedConstant.Value is int concurrencyInt)
                    {
                        concurrency = (SoftCacheConcurrency)concurrencyInt;
                    }
                    else if (typedConstant.Value is { } concurrencyObj && concurrencyObj is not null &&
                             typedConstant.Type?.TypeKind == TypeKind.Enum)
                    {
                        concurrency = (SoftCacheConcurrency)Convert.ToInt32(concurrencyObj);
                    }
                    break;

                case nameof(SoftCacheOptions.GenerateGlobalSeed):
                    if (typedConstant.Value is bool seed)
                    {
                        generateSeed = seed;
                    }
                    break;

                case nameof(SoftCacheOptions.EnableDebugMetrics):
                    if (typedConstant.Value is bool metrics)
                    {
                        debugMetrics = metrics;
                    }
                    break;

                case nameof(SoftCacheOptions.Domain):
                    if (typedConstant.Value is string domainValue)
                    {
                        domain = domainValue;
                    }
                    break;
            }
        }

        // Simple validation/normalization
        if (cacheBits is < 1 or > 16) cacheBits = 16;
        if (associativity < 1) associativity = 1;
        if (associativity > 4) associativity = 4;

        return new SoftCacheOptions
        {
            CacheBits = cacheBits,
            Associativity = associativity,
            HashKind = hashKind,
            Concurrency = concurrency,
            GenerateGlobalSeed = generateSeed,
            EnableDebugMetrics = debugMetrics,
            Domain = domain,
            TargetType = targetType
        };
    }
}